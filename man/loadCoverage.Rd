% Generated by roxygen2 (4.0.1): do not edit by hand
\name{loadCoverage}
\alias{loadCoverage}
\alias{load_coverage}
\title{Load the coverage information from a group of BAM files}
\usage{
loadCoverage(dirs, chr, cutoff = NULL, bai = NULL, chrlen = NULL,
  output = NULL, inputType = "bam", isMinusStrand = NA, filter = "one",
  returnMean = FALSE, returnCoverage = TRUE, totalMapped = NULL,
  targetSize = 8e+07, tilewidth = NULL, mc.cores = 1,
  mc.outfile = Sys.getenv("SGE_STDERR_PATH"), verbose = TRUE)
}
\arguments{
\item{dirs}{A character vector with the full path to the sample BAM files
(or bigWig files).
The names are used for the column names of the DataFrame. Check
\link{makeBamList} for constructing \code{dirs}. \code{dirs} can also be a
\code{BamFileList} object created with \link[Rsamtools]{BamFileList} or a
\code{BigWigFileList} object created with \link[rtracklayer]{BigWigFileList}.}

\item{chr}{Chromosome to read. Should be in the format matching the one used
in the raw data.}

\item{cutoff}{This argument is passed to \link{filterData}.}

\item{bai}{The full path to the BAM index files. If \code{NULL} it is
assumed that the BAM index files are in the same location as the BAM files
and that they have the .bai extension. Ignored if \code{dirs} is a
\code{BamFileList} object or if \code{inputType=='bigWig'}.}

\item{chrlen}{The chromosome length in base pairs. If it's \code{NULL}, the
chromosome length is extracted from the BAM files.}

\item{output}{If \code{NULL} then no output is saved in disk. If \code{auto}
then an automatic name is constructed using UCSC names (chrXCovInfo.Rdata
for example). If another character is specified, then that name is used for #' the output file.}

\item{inputType}{Has to be either \code{bam} or \code{bigWig}. It specifies
the format of the raw data files.}

\item{isMinusStrand}{Use \code{TRUE} for negative strand alignments only,
\code{FALSE} for positive strands and \code{NA} for both. This argument is
passed to \link[Rsamtools]{scanBamFlag} when \code{inputType='bam'}.}

\item{filter}{This argument is passed to \link{filterData}.}

\item{returnMean}{This argument is passed to \link{filterData}.}

\item{returnCoverage}{This argument is passed to \link{filterData}.}

\item{totalMapped}{The total number of reads mapped for each sample.
Providing this data adjusts the coverage to reads in \code{targetSize}
library prior to filtering. By default, to reads per 80 million reads.}

\item{targetSize}{The target library size to adjust the coverage to. Used
only when \code{totalMapped} is specified.}

\item{tilewidth}{When specified, \link[GenomicRanges]{tileGenome} is used to
break up the chromosome into chunks.}

\item{mc.cores}{This argument is passed to \link[BiocParallel]{SnowParam}
to define the number of \code{workers}. You may use up to one core per tile.
Only used when \code{tilewidth} is specified.}

\item{mc.outfile}{This argument is passed to \link[BiocParallel]{SnowParam}
to specify the \code{outfile} for any output from the workers.
Only used when \code{tilewidth} is specified.}

\item{verbose}{If \code{TRUE} basic status updates will be printed along the
way.}
}
\value{
A list with two components.
\describe{
\item{coverage }{ is a DataFrame object where each column represents a
sample. The number of rows depends on the number of base pairs that passed
the cutoff and the information stored is the coverage at that given base.}
\item{position }{  is a logical Rle with the positions of the chromosome
that passed the cutoff.}
}
}
\description{
For a group of samples this function reads the coverage information for a
specific chromosome directly from the BAM files. It then merges them into a
DataFrame and removes the bases that do not pass the cutoff.
}
\examples{
datadir <- system.file('extdata', 'genomeData', package='derfinder')
dirs <- makeBamList(datadir=datadir, samplepatt='*accepted_hits.bam$',
    bamterm=NULL)
## Shorten the column names
names(dirs) <- gsub('_accepted_hits.bam', '', names(dirs))

## Read and filter the data, only for 2 files
dataSmall <- loadCoverage(dirs=dirs[1:2], chr='21', cutoff=0)

\dontrun{
## Read all the data
dataAll <- loadCoverage(dirs=dirs, chr='21', cutoff=0)

## For other examples this data is included in the package
identical(dataAll, genomeData)

## Read the coverage without applying any cutoff.
## This can be useful for downstream analysis including coverage plots.
dataRaw <- loadCoverage(dirs=dirs, chr='21', cutoff=NULL)

## Compare vs raw data provided in the package
identical(dataRaw, genomeDataRaw)

## Note that the object size is pretty much the same due to the Rle
## compression
print(object.size(dataRaw), units='Kb')


#################################################################

## The following code shows how to export the coverage to a BigWig file
library('rtracklayer')
sample1 <- RleList("chr21" = dataSmall$coverage[[1]])
export(sample1, "sample1.bw")

## Re-load it in R
sample1.new <- import("sample1.bw", selection = GRanges("chr21", IRanges(1,
   48129895)), as = "RleList")

## Compare them
sample1 - sample1.new
## Note that the original one is a RleList of integer-Rle while the new one
## is a RleList of numeric-Rle

#################################################################
## Below is an example of using loadCoverage(inputType='bigWig')

## First we need to export the second sample too
sample2 <- RleList("chr21" = dataSmall$coverage[[2]])
export(sample2, "sample2.bw")

## Now we can use loadCoverage
dataSmall.bigWig <- loadCoverage(c(ERR009101 = 'sample1.bw', ERR009102 =
    'sample2.bw'), chr="chr21", inputType="bigWig")

## We can compare the results
mapply(function(x, y) { x - y}, dataSmall$coverage,
    dataSmall.bigWig$coverage)
## Note that the only difference is the type of Rle (integer vs numeric) used
## to store the data.

}
}
\author{
Leonardo Collado-Torres, Andrew Jaffe
}

